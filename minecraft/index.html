<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Minecraft Clone</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            overflow: hidden;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #87CEEB;
        }
        canvas {
            display: block;
            cursor: none;
        }
        #ui {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 15px 30px;
            border-radius: 10px;
            z-index: 100;
            pointer-events: none;
            font-size: 14px;
        }
        #gamepad-status {
            position: fixed;
            top: 70px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 100, 0, 0.7);
            color: white;
            padding: 10px 20px;
            border-radius: 8px;
            z-index: 100;
            pointer-events: none;
            font-size: 12px;
            display: none;
        }
        #gamepad-status.connected {
            display: block;
        }
        #crosshair {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 20px;
            height: 20px;
            z-index: 100;
            pointer-events: none;
        }
        #crosshair::before,
        #crosshair::after {
            content: '';
            position: absolute;
            background: white;
            box-shadow: 0 0 2px black;
        }
        #crosshair::before {
            top: 50%;
            left: 0;
            width: 100%;
            height: 2px;
            transform: translateY(-50%);
        }
        #crosshair::after {
            left: 50%;
            top: 0;
            width: 2px;
            height: 100%;
            transform: translateX(-50%);
        }
        #inventory {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 5px;
            z-index: 100;
        }
        .inventory-slot {
            width: 60px;
            height: 60px;
            background: rgba(0, 0, 0, 0.5);
            border: 3px solid rgba(255, 255, 255, 0.3);
            border-radius: 5px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 32px;
            transition: all 0.2s;
            cursor: pointer;
        }
        .inventory-slot.active {
            border-color: white;
            background: rgba(255, 255, 255, 0.2);
            transform: scale(1.1);
        }
        .inventory-slot:hover {
            background: rgba(255, 255, 255, 0.1);
        }
        #instructions {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 40px;
            border-radius: 15px;
            text-align: center;
            z-index: 200;
            max-width: 500px;
        }
        #instructions h2 {
            margin-bottom: 20px;
            font-size: 24px;
        }
        #instructions p {
            margin-bottom: 15px;
            line-height: 1.6;
        }
        #instructions button {
            margin-top: 20px;
            padding: 15px 40px;
            font-size: 18px;
            background: #4CAF50;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            transition: background 0.3s;
        }
        #instructions button:hover {
            background: #45a049;
        }
        .controls {
            text-align: left;
            margin-top: 20px;
            padding: 15px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 5px;
        }
        .controls div {
            margin: 5px 0;
        }
    </style>
</head>
<body>
    <div id="ui">
        Position: <span id="position">0, 0, 0</span> |
        <span id="mode-indicator" style="color: #4CAF50;">âœˆï¸ é£›è¡Œãƒ¢ãƒ¼ãƒ‰</span>
    </div>
    <div id="gamepad-status">
        ğŸ® <span id="gamepad-name">Switch Pro Controller</span> æ¥ç¶šä¸­
    </div>
    <div id="crosshair"></div>
    <div id="inventory">
        <div class="inventory-slot active" data-block="grass">ğŸŒ±</div>
        <div class="inventory-slot" data-block="dirt">ğŸŸ«</div>
        <div class="inventory-slot" data-block="stone">â¬œ</div>
        <div class="inventory-slot" data-block="wood">ğŸŸ§</div>
        <div class="inventory-slot" data-block="leaves">ğŸŒ¿</div>
        <div class="inventory-slot" data-block="sand">ğŸŸ¨</div>
        <div class="inventory-slot" data-block="water">ğŸ’§</div>
        <div class="inventory-slot" data-block="glass">ğŸ”·</div>
    </div>

    <div id="instructions">
        <h2>ğŸ® Minecraft Clone</h2>
        <p>ã‚¯ãƒªãƒƒã‚¯ã—ã¦ã‚²ãƒ¼ãƒ ã‚’é–‹å§‹</p>
        <p id="gamepad-start-hint" style="display: none; color: #4CAF50; margin-top: 10px; font-weight: bold;">
            ã¾ãŸã¯ Aãƒœã‚¿ãƒ³ ã‚’æŠ¼ã—ã¦ã‚¹ã‚¿ãƒ¼ãƒˆ
        </p>
        <div class="controls">
            <div><strong>ç§»å‹•:</strong> W A S D / å·¦ã‚¹ãƒ†ã‚£ãƒƒã‚¯</div>
            <div><strong>è¦–ç‚¹:</strong> ãƒã‚¦ã‚¹ç§»å‹• / å³ã‚¹ãƒ†ã‚£ãƒƒã‚¯</div>
            <div><strong>ä¸Šæ˜‡:</strong> Space / Aãƒœã‚¿ãƒ³ï¼ˆé£›è¡Œæ™‚ï¼‰</div>
            <div><strong>ä¸‹é™:</strong> Shift / ZLãƒœã‚¿ãƒ³ï¼ˆé£›è¡Œæ™‚ï¼‰</div>
            <div><strong>é£›è¡Œåˆ‡æ›¿:</strong> F / Yãƒœã‚¿ãƒ³</div>
            <div><strong>ãƒ–ãƒ­ãƒƒã‚¯ç ´å£Š:</strong> å·¦ã‚¯ãƒªãƒƒã‚¯ / Bãƒœã‚¿ãƒ³</div>
            <div><strong>ãƒ–ãƒ­ãƒƒã‚¯é…ç½®:</strong> å³ã‚¯ãƒªãƒƒã‚¯ / Xãƒœã‚¿ãƒ³</div>
            <div><strong>ãƒ–ãƒ­ãƒƒã‚¯é¸æŠ:</strong> 1-8, ãƒã‚¦ã‚¹ãƒ›ã‚¤ãƒ¼ãƒ«, åå­—ã‚­ãƒ¼, L/R</div>
            <div><strong>çµ‚äº†:</strong> ESC / +ãƒœã‚¿ãƒ³</div>
        </div>
        <button onclick="startGame()">ã‚²ãƒ¼ãƒ ã‚¹ã‚¿ãƒ¼ãƒˆ</button>
    </div>

    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
        }
    }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';

        // ã‚²ãƒ¼ãƒ çŠ¶æ…‹
        const gameState = {
            world: new Map(),
            currentBlock: 'grass',
            velocity: new THREE.Vector3(),
            isJumping: false,
            canJump: false,
            gamepad: null,
            gamepadButtons: {},
            gamepadPrevButtons: {},
            flyMode: true, // ã‚¯ãƒªã‚¨ã‚¤ãƒ†ã‚£ãƒ–ãƒ¢ãƒ¼ãƒ‰ï¼ˆé£›è¡Œï¼‰
            mobs: [] // ãƒ¢ãƒ–ã®é…åˆ—
        };

        // ã‚·ãƒ¼ãƒ³è¨­å®š
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87CEEB);
        scene.fog = new THREE.Fog(0x87CEEB, 0, 400); // ãƒ•ã‚©ã‚°è·é›¢ã‚’æ‹¡å¤§

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(-30, 30, -30); // æ‘ã®è¿‘ãã‹ã‚‰ã‚¹ã‚¿ãƒ¼ãƒˆ

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.body.appendChild(renderer.domElement);

        // ãƒ©ã‚¤ãƒˆè¨­å®š
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);

        const sunLight = new THREE.DirectionalLight(0xffffff, 0.6);
        sunLight.position.set(100, 150, 100);
        sunLight.castShadow = true;
        sunLight.shadow.camera.left = -200;
        sunLight.shadow.camera.right = 200;
        sunLight.shadow.camera.top = 200;
        sunLight.shadow.camera.bottom = -200;
        sunLight.shadow.camera.far = 400;
        sunLight.shadow.mapSize.width = 2048;
        sunLight.shadow.mapSize.height = 2048;
        scene.add(sunLight);

        // ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ«
        const controls = new PointerLockControls(camera, document.body);

        // ãƒ–ãƒ­ãƒƒã‚¯ãƒ†ã‚¯ã‚¹ãƒãƒ£ãƒãƒ†ãƒªã‚¢ãƒ«
        const blockMaterials = {
            grass: [
                new THREE.MeshLambertMaterial({ color: 0x3d8f3d }), // å³
                new THREE.MeshLambertMaterial({ color: 0x3d8f3d }), // å·¦
                new THREE.MeshLambertMaterial({ color: 0x7ec850 }), // ä¸Š
                new THREE.MeshLambertMaterial({ color: 0x6b4423 }), // ä¸‹
                new THREE.MeshLambertMaterial({ color: 0x3d8f3d }), // å‰
                new THREE.MeshLambertMaterial({ color: 0x3d8f3d })  // å¾Œ
            ],
            dirt: new THREE.MeshLambertMaterial({ color: 0x6b4423 }),
            stone: new THREE.MeshLambertMaterial({ color: 0x808080 }),
            wood: new THREE.MeshLambertMaterial({ color: 0x8b6914 }),
            leaves: new THREE.MeshLambertMaterial({ color: 0x228b22, transparent: true, opacity: 0.8 }),
            sand: new THREE.MeshLambertMaterial({ color: 0xc2b280 }),
            water: new THREE.MeshLambertMaterial({ color: 0x1e90ff, transparent: true, opacity: 0.6 }),
            glass: new THREE.MeshLambertMaterial({ color: 0xadd8e6, transparent: true, opacity: 0.4 })
        };

        // ãƒ–ãƒ­ãƒƒã‚¯ã‚¸ã‚ªãƒ¡ãƒˆãƒª
        const blockGeometry = new THREE.BoxGeometry(1, 1, 1);

        // ç°¡æ˜“çš„ãªãƒã‚¤ã‚ºç”Ÿæˆï¼ˆåœ°å½¢ç”¨ï¼‰
        function noise2D(x, z) {
            const X = Math.floor(x) & 255;
            const Z = Math.floor(z) & 255;
            return (Math.sin(X * 12.9898 + Z * 78.233) * 43758.5453123) % 1;
        }

        function getHeight(x, z) {
            const scale = 0.1;
            const n1 = noise2D(x * scale, z * scale);
            const n2 = noise2D(x * scale * 2, z * scale * 2) * 0.5;
            return Math.floor((n1 + n2) * 8) + 5;
        }

        // ãƒ¯ãƒ¼ãƒ«ãƒ‰åº§æ¨™ã‚’ã‚­ãƒ¼ã«å¤‰æ›
        function blockKey(x, y, z) {
            return `${Math.floor(x)},${Math.floor(y)},${Math.floor(z)}`;
        }

        // ãƒ–ãƒ­ãƒƒã‚¯è¿½åŠ 
        function addBlock(x, y, z, type) {
            const key = blockKey(x, y, z);
            if (gameState.world.has(key)) return;

            const material = blockMaterials[type];
            const mesh = new THREE.Mesh(blockGeometry, material);
            mesh.position.set(x, y, z);
            mesh.castShadow = true;
            mesh.receiveShadow = true;
            mesh.userData.blockType = type;

            scene.add(mesh);
            gameState.world.set(key, mesh);
        }

        // ãƒ–ãƒ­ãƒƒã‚¯å‰Šé™¤
        function removeBlock(x, y, z) {
            const key = blockKey(x, y, z);
            const block = gameState.world.get(key);
            if (block) {
                scene.remove(block);
                gameState.world.delete(key);
            }
        }

        // æ‘ç”Ÿæˆ
        function generateVillage(centerX, centerZ) {
            const groundY = getHeight(centerX, centerZ);

            console.log(`Generating village at (${centerX}, ${centerZ})`);

            // äº•æˆ¸ï¼ˆä¸­å¿ƒï¼‰
            function buildWell(x, z) {
                const y = groundY;
                // äº•æˆ¸ã®æ ï¼ˆçŸ³ï¼‰
                for (let dx = -1; dx <= 1; dx++) {
                    for (let dz = -1; dz <= 1; dz++) {
                        if (Math.abs(dx) === 1 || Math.abs(dz) === 1) {
                            addBlock(x + dx, y + 1, z + dz, 'stone');
                            addBlock(x + dx, y + 2, z + dz, 'stone');
                        }
                    }
                }
                // ä¸­å¤®ã®æ°´
                addBlock(x, y + 1, z, 'water');
            }

            // å®¶ã‚’å»ºã¦ã‚‹
            function buildHouse(x, z, direction) {
                const y = groundY;
                const width = 5;
                const depth = 5;
                const height = 4;

                // åºŠ
                for (let dx = 0; dx < width; dx++) {
                    for (let dz = 0; dz < depth; dz++) {
                        addBlock(x + dx, y, z + dz, 'wood');
                    }
                }

                // å£
                for (let h = 1; h <= height; h++) {
                    for (let dx = 0; dx < width; dx++) {
                        for (let dz = 0; dz < depth; dz++) {
                            const isWall = dx === 0 || dx === width - 1 || dz === 0 || dz === depth - 1;
                            const isDoor = (h <= 2 && dx === 2 && dz === 0); // ãƒ‰ã‚¢
                            const isWindow = (h === 2 && ((dx === 1 || dx === 3) && dz === depth - 1)); // çª“

                            if (isWall && !isDoor) {
                                if (isWindow) {
                                    addBlock(x + dx, y + h, z + dz, 'glass');
                                } else {
                                    addBlock(x + dx, y + h, z + dz, 'wood');
                                }
                            }
                        }
                    }
                }

                // å±‹æ ¹ï¼ˆä¸‰è§’å±‹æ ¹é¢¨ï¼‰
                for (let layer = 0; layer < 2; layer++) {
                    for (let dx = layer; dx < width - layer; dx++) {
                        for (let dz = layer; dz < depth - layer; dz++) {
                            addBlock(x + dx, y + height + layer + 1, z + dz, 'wood');
                        }
                    }
                }
            }

            // ç•‘ã‚’ä½œã‚‹
            function buildFarm(x, z) {
                const y = groundY;
                for (let dx = 0; dx < 6; dx++) {
                    for (let dz = 0; dz < 6; dz++) {
                        addBlock(x + dx, y, z + dz, 'dirt');
                        // ä½œç‰©ï¼ˆè‰ãƒ–ãƒ­ãƒƒã‚¯ã§ä»£ç”¨ï¼‰
                        if ((dx + dz) % 2 === 0 && dx > 0 && dz > 0) {
                            addBlock(x + dx, y + 1, z + dz, 'leaves');
                        }
                    }
                }
            }

            // é“ã‚’ä½œã‚‹
            function buildRoad(x1, z1, x2, z2) {
                const y = groundY;
                const steps = Math.max(Math.abs(x2 - x1), Math.abs(z2 - z1));
                for (let i = 0; i <= steps; i++) {
                    const t = i / steps;
                    const x = Math.floor(x1 + (x2 - x1) * t);
                    const z = Math.floor(z1 + (z2 - z1) * t);
                    addBlock(x, y, z, 'stone');
                    addBlock(x + 1, y, z, 'stone');
                    addBlock(x, y, z + 1, 'stone');
                }
            }

            // äº•æˆ¸ã‚’ä¸­å¿ƒã«é…ç½®
            buildWell(centerX, centerZ);

            // å®¶ã‚’å‘¨ã‚Šã«é…ç½®
            const housePositions = [
                { x: centerX - 12, z: centerZ - 12 },
                { x: centerX + 8, z: centerZ - 12 },
                { x: centerX - 12, z: centerZ + 8 },
                { x: centerX + 8, z: centerZ + 8 }
            ];

            housePositions.forEach(pos => {
                buildHouse(pos.x, pos.z, 0);
                buildRoad(centerX, centerZ, pos.x + 2, pos.z + 2);
            });

            // ç•‘ã‚’é…ç½®
            buildFarm(centerX - 8, centerZ - 8);
            buildFarm(centerX + 4, centerZ + 4);

            // æ‘äººã‚’ã‚¹ãƒãƒ¼ãƒ³
            for (let i = 0; i < 3; i++) {
                const x = centerX + (Math.random() - 0.5) * 15;
                const z = centerZ + (Math.random() - 0.5) * 15;
                spawnMob('cow', x, z); // æ‘äººã®ä»£ã‚ã‚Šã«ç‰›ã‚’é…ç½®ï¼ˆå¾Œã§æ‘äººãƒ¢ãƒ–ã‚’è¿½åŠ å¯èƒ½ï¼‰
            }
        }

        // ãƒ¯ãƒ¼ãƒ«ãƒ‰ç”Ÿæˆ
        function generateWorld() {
            const size = 60; // ãƒãƒƒãƒ—ã‚µã‚¤ã‚ºã‚’2å€ã«æ‹¡å¤§
            for (let x = -size; x < size; x++) {
                for (let z = -size; z < size; z++) {
                    const height = getHeight(x, z);

                    // åœ°å½¢ç”Ÿæˆ
                    for (let y = 0; y < height; y++) {
                        if (y === height - 1) {
                            addBlock(x, y, z, 'grass');
                        } else if (y > height - 4) {
                            addBlock(x, y, z, 'dirt');
                        } else {
                            addBlock(x, y, z, 'stone');
                        }
                    }

                    // ãƒ©ãƒ³ãƒ€ãƒ ã«æœ¨ã‚’ç”Ÿæˆ
                    if (Math.random() < 0.02 && height > 6) {
                        const treeHeight = 5;
                        // å¹¹
                        for (let i = 0; i < treeHeight; i++) {
                            addBlock(x, height + i, z, 'wood');
                        }
                        // è‘‰
                        for (let dx = -2; dx <= 2; dx++) {
                            for (let dz = -2; dz <= 2; dz++) {
                                for (let dy = 0; dy < 3; dy++) {
                                    if (Math.abs(dx) === 2 && Math.abs(dz) === 2 && dy < 2) continue;
                                    addBlock(x + dx, height + treeHeight + dy, z + dz, 'leaves');
                                }
                            }
                        }
                    }
                }
            }

            // ãƒ¢ãƒ–ã‚¹ãƒãƒ¼ãƒ³ï¼ˆãƒãƒƒãƒ—æ‹¡å¤§ã«ä¼´ã„æ•°ã‚’å¢—ã‚„ã™ï¼‰
            console.log('Spawning mobs...');

            // å‹å¥½çš„ãƒ¢ãƒ–ã‚’ã‚¹ãƒãƒ¼ãƒ³
            for (let i = 0; i < 20; i++) {
                const x = (Math.random() - 0.5) * 100;
                const z = (Math.random() - 0.5) * 100;
                spawnMob('cow', x, z);
            }

            for (let i = 0; i < 15; i++) {
                const x = (Math.random() - 0.5) * 100;
                const z = (Math.random() - 0.5) * 100;
                spawnMob('pig', x, z);
            }

            for (let i = 0; i < 15; i++) {
                const x = (Math.random() - 0.5) * 100;
                const z = (Math.random() - 0.5) * 100;
                spawnMob('sheep', x, z);
            }

            for (let i = 0; i < 10; i++) {
                const x = (Math.random() - 0.5) * 100;
                const z = (Math.random() - 0.5) * 100;
                spawnMob('chicken', x, z);
            }

            // æ•µå¯¾çš„ãƒ¢ãƒ–ã‚’ã‚¹ãƒãƒ¼ãƒ³
            for (let i = 0; i < 10; i++) {
                const x = (Math.random() - 0.5) * 100;
                const z = (Math.random() - 0.5) * 100;
                spawnMob('zombie', x, z);
            }

            for (let i = 0; i < 8; i++) {
                const x = (Math.random() - 0.5) * 100;
                const z = (Math.random() - 0.5) * 100;
                spawnMob('skeleton', x, z);
            }

            for (let i = 0; i < 6; i++) {
                const x = (Math.random() - 0.5) * 100;
                const z = (Math.random() - 0.5) * 100;
                spawnMob('creeper', x, z);
            }

            console.log(`Spawned ${gameState.mobs.length} mobs`);

            // æ‘ã‚’ç”Ÿæˆï¼ˆ3ã¤ï¼‰
            console.log('Generating villages...');
            generateVillage(-40, -40);
            generateVillage(40, 40);
            generateVillage(-40, 40);
            console.log('Villages generated!');
        }

        // ãƒ¢ãƒ–ã‚·ã‚¹ãƒ†ãƒ 
        class Mob {
            constructor(x, y, z, type) {
                this.type = type;
                this.position = new THREE.Vector3(x, y, z);
                this.velocity = new THREE.Vector3();
                this.health = 20;
                this.maxHealth = 20;
                this.speed = 2;
                this.target = null;
                this.state = 'idle'; // idle, walking, attacking
                this.stateTimer = 0;

                // ãƒ¢ãƒ‡ãƒ«ä½œæˆ
                this.group = new THREE.Group();
                this.createModel();
                this.group.position.copy(this.position);
                scene.add(this.group);
            }

            createModel() {
                // å­ã‚¯ãƒ©ã‚¹ã§ã‚ªãƒ¼ãƒãƒ¼ãƒ©ã‚¤ãƒ‰
            }

            update(delta) {
                this.stateTimer += delta;

                // AIæ›´æ–°
                this.updateAI(delta);

                // é‡åŠ›
                this.velocity.y -= 20 * delta;

                // ç§»å‹•
                this.position.add(this.velocity.clone().multiplyScalar(delta));

                // åœ°é¢è¡çªï¼ˆç°¡æ˜“ï¼‰
                if (this.position.y < getHeight(this.position.x, this.position.z) + 1) {
                    this.position.y = getHeight(this.position.x, this.position.z) + 1;
                    this.velocity.y = 0;
                }

                // ä½ç½®åŒæœŸ
                this.group.position.copy(this.position);

                // ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³
                if (this.velocity.x !== 0 || this.velocity.z !== 0) {
                    this.group.rotation.y = Math.atan2(this.velocity.x, this.velocity.z);
                }
            }

            updateAI(delta) {
                // å­ã‚¯ãƒ©ã‚¹ã§ã‚ªãƒ¼ãƒãƒ¼ãƒ©ã‚¤ãƒ‰
            }

            takeDamage(amount) {
                this.health -= amount;
                if (this.health <= 0) {
                    this.die();
                }
            }

            die() {
                scene.remove(this.group);
                const index = gameState.mobs.indexOf(this);
                if (index > -1) {
                    gameState.mobs.splice(index, 1);
                }
            }

            distanceToPlayer() {
                return this.position.distanceTo(camera.position);
            }
        }

        // å‹å¥½çš„ãƒ¢ãƒ–
        class PassiveMob extends Mob {
            createModel() {
                const bodyGeo = new THREE.BoxGeometry(0.6, 0.8, 1);
                const headGeo = new THREE.BoxGeometry(0.5, 0.5, 0.5);
                const legGeo = new THREE.BoxGeometry(0.2, 0.5, 0.2);

                let bodyColor, headColor;
                if (this.type === 'cow') {
                    bodyColor = 0x8B4513; // èŒ¶è‰²
                    headColor = 0x654321;
                } else if (this.type === 'pig') {
                    bodyColor = 0xFFB6C1; // ãƒ”ãƒ³ã‚¯
                    headColor = 0xFFB6C1;
                } else if (this.type === 'sheep') {
                    bodyColor = 0xFFFFFF; // ç™½
                    headColor = 0xE0E0E0;
                } else if (this.type === 'chicken') {
                    bodyColor = 0xFFFFFF;
                    headColor = 0xFF0000; // èµ¤ã„ãƒˆã‚µã‚«
                }

                const bodyMat = new THREE.MeshLambertMaterial({ color: bodyColor });
                const headMat = new THREE.MeshLambertMaterial({ color: headColor });
                const legMat = new THREE.MeshLambertMaterial({ color: bodyColor });

                // ä½“
                const body = new THREE.Mesh(bodyGeo, bodyMat);
                body.position.y = 0.4;
                body.castShadow = true;
                this.group.add(body);

                // é ­
                const head = new THREE.Mesh(headGeo, headMat);
                head.position.set(0, 0.7, -0.6);
                head.castShadow = true;
                this.group.add(head);

                // è¶³ï¼ˆ4æœ¬ï¼‰
                const positions = [
                    [-0.25, -0.25, 0.3],
                    [0.25, -0.25, 0.3],
                    [-0.25, -0.25, -0.3],
                    [0.25, -0.25, -0.3]
                ];

                positions.forEach(pos => {
                    const leg = new THREE.Mesh(legGeo, legMat);
                    leg.position.set(pos[0], pos[1], pos[2]);
                    leg.castShadow = true;
                    this.group.add(leg);
                });
            }

            updateAI(delta) {
                // ãƒ©ãƒ³ãƒ€ãƒ ã‚¦ã‚©ãƒ¼ã‚¯
                if (this.stateTimer > 3) {
                    this.stateTimer = 0;
                    if (Math.random() < 0.3) {
                        this.state = 'walking';
                        const angle = Math.random() * Math.PI * 2;
                        this.velocity.x = Math.cos(angle) * this.speed;
                        this.velocity.z = Math.sin(angle) * this.speed;
                    } else {
                        this.state = 'idle';
                        this.velocity.x = 0;
                        this.velocity.z = 0;
                    }
                }
            }
        }

        // æ•µå¯¾çš„ãƒ¢ãƒ–
        class HostileMob extends Mob {
            constructor(x, y, z, type) {
                super(x, y, z, type);
                this.attackDamage = 3;
                this.attackCooldown = 0;
                this.detectionRange = 20;
                this.attackRange = 2;
            }

            createModel() {
                const bodyGeo = new THREE.BoxGeometry(0.6, 1.5, 0.3);
                const headGeo = new THREE.BoxGeometry(0.5, 0.5, 0.5);
                const armGeo = new THREE.BoxGeometry(0.2, 1, 0.2);
                const legGeo = new THREE.BoxGeometry(0.2, 1, 0.2);

                let bodyColor, headColor;
                if (this.type === 'zombie') {
                    bodyColor = 0x00AA00; // ç·‘
                    headColor = 0x00AA00;
                } else if (this.type === 'skeleton') {
                    bodyColor = 0xCCCCCC; // ç™½éª¨
                    headColor = 0xCCCCCC;
                } else if (this.type === 'creeper') {
                    bodyColor = 0x0D9400; // ã‚¯ãƒªãƒ¼ãƒ‘ãƒ¼ç·‘
                    headColor = 0x0D9400;
                }

                const bodyMat = new THREE.MeshLambertMaterial({ color: bodyColor });
                const headMat = new THREE.MeshLambertMaterial({ color: headColor });

                // ä½“
                const body = new THREE.Mesh(bodyGeo, bodyMat);
                body.position.y = 0.75;
                body.castShadow = true;
                this.group.add(body);

                // é ­
                const head = new THREE.Mesh(headGeo, headMat);
                head.position.y = 1.75;
                head.castShadow = true;
                this.group.add(head);

                // ç›®ï¼ˆæ•µå¯¾çš„ãªèµ¤ã„ç›®ï¼‰
                const eyeGeo = new THREE.BoxGeometry(0.1, 0.1, 0.05);
                const eyeMat = new THREE.MeshBasicMaterial({ color: 0xFF0000 });
                const leftEye = new THREE.Mesh(eyeGeo, eyeMat);
                leftEye.position.set(-0.15, 1.8, -0.28);
                this.group.add(leftEye);
                const rightEye = new THREE.Mesh(eyeGeo, eyeMat);
                rightEye.position.set(0.15, 1.8, -0.28);
                this.group.add(rightEye);

                // è…•
                const leftArm = new THREE.Mesh(armGeo, bodyMat);
                leftArm.position.set(-0.45, 0.75, 0);
                leftArm.castShadow = true;
                this.group.add(leftArm);

                const rightArm = new THREE.Mesh(armGeo, bodyMat);
                rightArm.position.set(0.45, 0.75, 0);
                rightArm.castShadow = true;
                this.group.add(rightArm);

                // è¶³
                const leftLeg = new THREE.Mesh(legGeo, bodyMat);
                leftLeg.position.set(-0.15, -0.5, 0);
                leftLeg.castShadow = true;
                this.group.add(leftLeg);

                const rightLeg = new THREE.Mesh(legGeo, bodyMat);
                rightLeg.position.set(0.15, -0.5, 0);
                rightLeg.castShadow = true;
                this.group.add(rightLeg);
            }

            updateAI(delta) {
                const distToPlayer = this.distanceToPlayer();

                if (this.attackCooldown > 0) {
                    this.attackCooldown -= delta;
                }

                // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼æ¤œå‡º
                if (distToPlayer < this.detectionRange) {
                    this.state = 'chasing';

                    // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã«å‘ã‹ã£ã¦ç§»å‹•
                    const dirToPlayer = new THREE.Vector3()
                        .subVectors(camera.position, this.position)
                        .normalize();

                    dirToPlayer.y = 0;

                    if (distToPlayer > this.attackRange) {
                        this.velocity.x = dirToPlayer.x * this.speed * 1.5;
                        this.velocity.z = dirToPlayer.z * this.speed * 1.5;
                    } else {
                        // æ”»æ’ƒç¯„å›²å†…
                        this.velocity.x = 0;
                        this.velocity.z = 0;

                        if (this.attackCooldown <= 0) {
                            this.attack();
                            this.attackCooldown = 1.5;
                        }
                    }
                } else {
                    // ãƒ©ãƒ³ãƒ€ãƒ ã‚¦ã‚©ãƒ¼ã‚¯
                    if (this.stateTimer > 4) {
                        this.stateTimer = 0;
                        if (Math.random() < 0.2) {
                            const angle = Math.random() * Math.PI * 2;
                            this.velocity.x = Math.cos(angle) * this.speed;
                            this.velocity.z = Math.sin(angle) * this.speed;
                        } else {
                            this.velocity.x = 0;
                            this.velocity.z = 0;
                        }
                    }
                }
            }

            attack() {
                console.log(`${this.type} attacks! (damage: ${this.attackDamage})`);
                // ã“ã“ã§ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã«ãƒ€ãƒ¡ãƒ¼ã‚¸ã‚’ä¸ãˆã‚‹å‡¦ç†ã‚’è¿½åŠ å¯èƒ½
            }
        }

        // ã‚¯ãƒªãƒ¼ãƒ‘ãƒ¼ï¼ˆç‰¹æ®Šï¼‰
        class Creeper extends HostileMob {
            constructor(x, y, z) {
                super(x, y, z, 'creeper');
                this.explosionTimer = 0;
                this.explosionDelay = 1.5;
                this.isExploding = false;
            }

            updateAI(delta) {
                const distToPlayer = this.distanceToPlayer();

                if (distToPlayer < this.detectionRange) {
                    const dirToPlayer = new THREE.Vector3()
                        .subVectors(camera.position, this.position)
                        .normalize();
                    dirToPlayer.y = 0;

                    if (distToPlayer > 3) {
                        this.velocity.x = dirToPlayer.x * this.speed * 1.5;
                        this.velocity.z = dirToPlayer.z * this.speed * 1.5;
                        this.isExploding = false;
                        this.explosionTimer = 0;
                    } else {
                        // çˆ†ç™ºé–‹å§‹
                        this.velocity.x = 0;
                        this.velocity.z = 0;
                        this.isExploding = true;
                        this.explosionTimer += delta;

                        // ç‚¹æ»…ã‚¨ãƒ•ã‚§ã‚¯ãƒˆ
                        if (Math.floor(this.explosionTimer * 4) % 2 === 0) {
                            this.group.scale.set(1.2, 1.2, 1.2);
                        } else {
                            this.group.scale.set(1, 1, 1);
                        }

                        if (this.explosionTimer >= this.explosionDelay) {
                            this.explode();
                        }
                    }
                } else {
                    super.updateAI(delta);
                    this.isExploding = false;
                    this.explosionTimer = 0;
                }
            }

            explode() {
                console.log('ğŸ’¥ Creeper exploded!');

                // çˆ†ç™ºã‚¨ãƒ•ã‚§ã‚¯ãƒˆï¼ˆå‘¨å›²ã®ãƒ–ãƒ­ãƒƒã‚¯ã‚’ç ´å£Šï¼‰
                const explosionRadius = 3;
                for (let dx = -explosionRadius; dx <= explosionRadius; dx++) {
                    for (let dy = -explosionRadius; dy <= explosionRadius; dy++) {
                        for (let dz = -explosionRadius; dz <= explosionRadius; dz++) {
                            const dist = Math.sqrt(dx*dx + dy*dy + dz*dz);
                            if (dist <= explosionRadius) {
                                const bx = Math.floor(this.position.x + dx);
                                const by = Math.floor(this.position.y + dy);
                                const bz = Math.floor(this.position.z + dz);
                                removeBlock(bx, by, bz);
                            }
                        }
                    }
                }

                this.die();
            }
        }

        // ãƒ¢ãƒ–ã‚¹ãƒãƒ¼ãƒ³
        function spawnMob(type, x, z) {
            const y = getHeight(x, z) + 1;
            let mob;

            if (type === 'zombie') {
                mob = new HostileMob(x, y, z, 'zombie');
            } else if (type === 'skeleton') {
                mob = new HostileMob(x, y, z, 'skeleton');
            } else if (type === 'creeper') {
                mob = new Creeper(x, y, z);
            } else if (['cow', 'pig', 'sheep', 'chicken'].includes(type)) {
                mob = new PassiveMob(x, y, z, type);
            }

            if (mob) {
                gameState.mobs.push(mob);
            }
        }

        // ãƒ¬ã‚¤ã‚­ãƒ£ã‚¹ãƒˆï¼ˆãƒ–ãƒ­ãƒƒã‚¯é¸æŠç”¨ï¼‰
        const raycaster = new THREE.Raycaster();
        raycaster.far = 10;

        function getTargetBlock() {
            raycaster.setFromCamera(new THREE.Vector2(0, 0), camera);
            const intersects = raycaster.intersectObjects(Array.from(gameState.world.values()));
            return intersects.length > 0 ? intersects[0] : null;
        }

        function getTargetMob() {
            raycaster.setFromCamera(new THREE.Vector2(0, 0), camera);
            const mobObjects = gameState.mobs.map(mob => mob.group);
            const intersects = raycaster.intersectObjects(mobObjects, true);
            if (intersects.length > 0) {
                // æœ€ã‚‚è¿‘ã„ãƒ¢ãƒ–ã‚’è¦‹ã¤ã‘ã‚‹
                for (const mob of gameState.mobs) {
                    if (mob.group === intersects[0].object || mob.group.children.includes(intersects[0].object)) {
                        return mob;
                    }
                }
            }
            return null;
        }

        // è¡çªåˆ¤å®š
        function checkCollision(position) {
            const playerBox = new THREE.Box3(
                new THREE.Vector3(position.x - 0.3, position.y - 1.5, position.z - 0.3),
                new THREE.Vector3(position.x + 0.3, position.y + 0.3, position.z + 0.3)
            );

            for (const [key, block] of gameState.world) {
                const blockBox = new THREE.Box3().setFromObject(block);
                if (playerBox.intersectsBox(blockBox)) {
                    return true;
                }
            }
            return false;
        }

        // ã‚­ãƒ¼ãƒœãƒ¼ãƒ‰å…¥åŠ›
        const keys = {};
        document.addEventListener('keydown', (e) => {
            keys[e.code] = true;

            // ãƒ–ãƒ­ãƒƒã‚¯é¸æŠï¼ˆæ•°å­—ã‚­ãƒ¼ï¼‰
            if (e.code >= 'Digit1' && e.code <= 'Digit8') {
                const index = parseInt(e.code.slice(-1)) - 1;
                const slots = document.querySelectorAll('.inventory-slot');
                if (slots[index]) {
                    slots.forEach(s => s.classList.remove('active'));
                    slots[index].classList.add('active');
                    gameState.currentBlock = slots[index].dataset.block;
                }
            }

            // é£›è¡Œãƒ¢ãƒ¼ãƒ‰åˆ‡æ›¿ï¼ˆFã‚­ãƒ¼ï¼‰
            if (e.code === 'KeyF' && controls.isLocked) {
                gameState.flyMode = !gameState.flyMode;
                const modeIndicator = document.getElementById('mode-indicator');
                if (gameState.flyMode) {
                    modeIndicator.textContent = 'âœˆï¸ é£›è¡Œãƒ¢ãƒ¼ãƒ‰';
                    modeIndicator.style.color = '#4CAF50';
                } else {
                    modeIndicator.textContent = 'ğŸš¶ æ­©è¡Œãƒ¢ãƒ¼ãƒ‰';
                    modeIndicator.style.color = '#FFA500';
                }
                console.log('é£›è¡Œãƒ¢ãƒ¼ãƒ‰:', gameState.flyMode);
            }
        });

        document.addEventListener('keyup', (e) => {
            keys[e.code] = false;
        });

        // ãƒã‚¦ã‚¹å…¥åŠ›
        document.addEventListener('mousedown', (e) => {
            if (!controls.isLocked) return;

            if (e.button === 0) {
                // å·¦ã‚¯ãƒªãƒƒã‚¯ï¼šãƒ¢ãƒ–ã¾ãŸã¯ãƒ–ãƒ­ãƒƒã‚¯æ”»æ’ƒ
                const targetMob = getTargetMob();
                if (targetMob) {
                    // ãƒ¢ãƒ–ã‚’æ”»æ’ƒ
                    targetMob.takeDamage(5);
                    console.log(`Hit ${targetMob.type}! HP: ${targetMob.health}/${targetMob.maxHealth}`);
                } else {
                    // ãƒ–ãƒ­ãƒƒã‚¯ç ´å£Š
                    const target = getTargetBlock();
                    if (target) {
                        const pos = target.object.position;
                        removeBlock(pos.x, pos.y, pos.z);
                    }
                }
            } else if (e.button === 2) {
                const target = getTargetBlock();
                if (!target) return;
                // å³ã‚¯ãƒªãƒƒã‚¯ï¼šãƒ–ãƒ­ãƒƒã‚¯é…ç½®
                e.preventDefault();
                const normal = target.face.normal;
                const pos = target.object.position.clone().add(normal);

                // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®ä¸­å¿ƒéƒ¨åˆ†ã¨é‡ãªã‚‰ãªã„ã‹ç¢ºèªï¼ˆè¶³å…ƒã¨é ­ä¸Šã¯è¨±å¯ï¼‰
                const playerPos = camera.position;
                const dx = Math.abs(pos.x - playerPos.x);
                const dy = pos.y - playerPos.y;
                const dz = Math.abs(pos.z - playerPos.z);

                // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®ä¸­å¿ƒã‹ã‚‰0.5mä»¥å†…ã§ã€ã‹ã¤é«˜ã•ãŒ-0.5ã€œ0.5ã®ç¯„å›²ã«ã‚ã‚‹å ´åˆã®ã¿ãƒ–ãƒ­ãƒƒã‚¯
                const tooClose = dx < 0.5 && dz < 0.5 && dy > -1.5 && dy < 0.5;

                if (!tooClose) {
                    addBlock(pos.x, pos.y, pos.z, gameState.currentBlock);
                }
            }
        });

        document.addEventListener('contextmenu', (e) => e.preventDefault());

        // ãƒã‚¦ã‚¹ãƒ›ã‚¤ãƒ¼ãƒ«ï¼ˆãƒ–ãƒ­ãƒƒã‚¯é¸æŠï¼‰
        document.addEventListener('wheel', (e) => {
            if (!controls.isLocked) return;

            const slots = document.querySelectorAll('.inventory-slot');
            const activeIndex = Array.from(slots).findIndex(s => s.classList.contains('active'));

            let newIndex = activeIndex + (e.deltaY > 0 ? 1 : -1);
            if (newIndex < 0) newIndex = slots.length - 1;
            if (newIndex >= slots.length) newIndex = 0;

            slots.forEach(s => s.classList.remove('active'));
            slots[newIndex].classList.add('active');
            gameState.currentBlock = slots[newIndex].dataset.block;
        });

        // ã‚¤ãƒ³ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒ­ãƒƒãƒˆã‚¯ãƒªãƒƒã‚¯
        document.querySelectorAll('.inventory-slot').forEach(slot => {
            slot.addEventListener('click', () => {
                document.querySelectorAll('.inventory-slot').forEach(s => s.classList.remove('active'));
                slot.classList.add('active');
                gameState.currentBlock = slot.dataset.block;
            });
        });

        // ã‚²ãƒ¼ãƒ ãƒ‘ãƒƒãƒ‰é–¢é€£
        window.addEventListener('gamepadconnected', (e) => {
            console.log('Gamepad connected:', e.gamepad);
            console.log('Gamepad details:', {
                id: e.gamepad.id,
                buttons: e.gamepad.buttons.length,
                axes: e.gamepad.axes.length
            });
            gameState.gamepad = e.gamepad;
            const statusEl = document.getElementById('gamepad-status');
            const nameEl = document.getElementById('gamepad-name');
            nameEl.textContent = e.gamepad.id;
            statusEl.classList.add('connected');

            // ã‚¹ã‚¿ãƒ¼ãƒˆç”»é¢ã®ãƒ’ãƒ³ãƒˆã‚’è¡¨ç¤º
            const hint = document.getElementById('gamepad-start-hint');
            if (hint) hint.style.display = 'block';
        });

        window.addEventListener('gamepaddisconnected', (e) => {
            console.log('Gamepad disconnected');
            gameState.gamepad = null;
            document.getElementById('gamepad-status').classList.remove('connected');

            // ãƒ’ãƒ³ãƒˆã‚’éè¡¨ç¤º
            const hint = document.getElementById('gamepad-start-hint');
            if (hint) hint.style.display = 'none';
        });

        // ã‚²ãƒ¼ãƒ ãƒ‘ãƒƒãƒ‰å…¥åŠ›å‡¦ç†
        function updateGamepad() {
            const gamepads = navigator.getGamepads();
            if (!gamepads) return null;

            for (const gp of gamepads) {
                if (gp && gp.connected) {
                    return gp;
                }
            }
            return null;
        }

        function selectInventorySlot(index) {
            const slots = document.querySelectorAll('.inventory-slot');
            if (index >= 0 && index < slots.length) {
                slots.forEach(s => s.classList.remove('active'));
                slots[index].classList.add('active');
                gameState.currentBlock = slots[index].dataset.block;
            }
        }

        function getActiveSlotIndex() {
            const slots = document.querySelectorAll('.inventory-slot');
            return Array.from(slots).findIndex(s => s.classList.contains('active'));
        }

        function isButtonPressed(gp, buttonIndex) {
            if (!gp || !gp.buttons[buttonIndex]) return false;
            return gp.buttons[buttonIndex].pressed;
        }

        function isButtonJustPressed(gp, buttonIndex) {
            const current = isButtonPressed(gp, buttonIndex);
            const prev = gameState.gamepadPrevButtons[buttonIndex] || false;
            gameState.gamepadPrevButtons[buttonIndex] = current;
            const justPressed = current && !prev;

            // ãƒ‡ãƒãƒƒã‚°: ãƒœã‚¿ãƒ³ãŒæŠ¼ã•ã‚ŒãŸã‚‰ãƒ­ã‚°å‡ºåŠ›
            if (justPressed) {
                console.log(`Button ${buttonIndex} pressed`);
            }

            return justPressed;
        }

        // ã‚²ãƒ¼ãƒ é–‹å§‹
        window.startGame = function() {
            document.getElementById('instructions').style.display = 'none';
            controls.lock();
        };

        controls.addEventListener('lock', () => {
            document.getElementById('instructions').style.display = 'none';
        });

        controls.addEventListener('unlock', () => {
            document.getElementById('instructions').style.display = 'block';
        });

        // ã‚²ãƒ¼ãƒ ãƒ‘ãƒƒãƒ‰ã§ã‚²ãƒ¼ãƒ é–‹å§‹
        function checkGamepadStart() {
            const instructions = document.getElementById('instructions');
            if (instructions.style.display !== 'none') {
                const gp = updateGamepad();

                // ãƒ‡ãƒãƒƒã‚°: çŠ¶æ…‹ã‚’ãƒ­ã‚°å‡ºåŠ›
                if (gp) {
                    // ã™ã¹ã¦ã®ãƒœã‚¿ãƒ³ã®çŠ¶æ…‹ã‚’ãƒã‚§ãƒƒã‚¯
                    const pressedButtons = [];
                    for (let i = 0; i < gp.buttons.length; i++) {
                        if (gp.buttons[i].pressed) {
                            pressedButtons.push(i);
                        }
                    }

                    if (pressedButtons.length > 0) {
                        console.log('Buttons currently pressed:', pressedButtons);
                    }

                    // Aãƒœã‚¿ãƒ³ï¼ˆãƒœã‚¿ãƒ³0ï¼‰ãŒæŠ¼ã•ã‚ŒãŸã‹ç›´æ¥ãƒã‚§ãƒƒã‚¯
                    if (gp.buttons[0] && gp.buttons[0].pressed) {
                        console.log('A button (0) is pressed! Starting game...');
                        startGame();
                    }
                }
            }
        }

        // ç‰©ç†æ¼”ç®—ã¨ã‚²ãƒ¼ãƒ ãƒ«ãƒ¼ãƒ—
        const clock = new THREE.Clock();
        let prevTime = performance.now();

        function animate() {
            requestAnimationFrame(animate);

            const time = performance.now();
            const delta = (time - prevTime) / 1000;

            // ãƒ¡ãƒ‹ãƒ¥ãƒ¼ç”»é¢ã§ã‚‚ã‚²ãƒ¼ãƒ ãƒ‘ãƒƒãƒ‰ã§ã‚¹ã‚¿ãƒ¼ãƒˆå¯èƒ½ã«
            checkGamepadStart();

            if (controls.isLocked) {
                // ã‚²ãƒ¼ãƒ ãƒ‘ãƒƒãƒ‰æ›´æ–°
                const gp = updateGamepad();

                // é‡åŠ›ï¼ˆæ­©è¡Œãƒ¢ãƒ¼ãƒ‰ã®ã¿ï¼‰
                if (!gameState.flyMode) {
                    gameState.velocity.y -= 30 * delta;
                } else {
                    // é£›è¡Œãƒ¢ãƒ¼ãƒ‰ã§ã¯é‡åŠ›ãªã—
                    gameState.velocity.y = 0;
                }

                // ç§»å‹•
                const moveSpeed = gameState.flyMode ? 15 : 10;
                const direction = new THREE.Vector3();

                // ã‚­ãƒ¼ãƒœãƒ¼ãƒ‰å…¥åŠ›
                if (keys['KeyW']) direction.z -= 1;
                if (keys['KeyS']) direction.z += 1;
                if (keys['KeyA']) direction.x -= 1;
                if (keys['KeyD']) direction.x += 1;

                // ã‚²ãƒ¼ãƒ ãƒ‘ãƒƒãƒ‰ å·¦ã‚¹ãƒ†ã‚£ãƒƒã‚¯å…¥åŠ›ï¼ˆãƒ‡ãƒƒãƒ‰ã‚¾ãƒ¼ãƒ³å‡¦ç†ï¼‰
                if (gp) {
                    const deadzone = 0.15;
                    const leftX = Math.abs(gp.axes[0]) > deadzone ? gp.axes[0] : 0;
                    const leftY = Math.abs(gp.axes[1]) > deadzone ? gp.axes[1] : 0;

                    direction.x += leftX;
                    direction.z += leftY;
                }

                direction.normalize();

                const forward = new THREE.Vector3();
                camera.getWorldDirection(forward);
                if (!gameState.flyMode) {
                    forward.y = 0; // æ­©è¡Œãƒ¢ãƒ¼ãƒ‰ã¯æ°´å¹³ç§»å‹•ã®ã¿
                }
                forward.normalize();

                const right = new THREE.Vector3();
                right.crossVectors(forward, camera.up).normalize();

                const moveVector = new THREE.Vector3();
                moveVector.addScaledVector(forward, -direction.z * moveSpeed * delta);
                moveVector.addScaledVector(right, direction.x * moveSpeed * delta);

                // é£›è¡Œãƒ¢ãƒ¼ãƒ‰ã§ã®ä¸Šæ˜‡ãƒ»ä¸‹é™
                if (gameState.flyMode) {
                    const flySpeed = 10;
                    // Space: ä¸Šæ˜‡ / Shift: ä¸‹é™
                    if (keys['Space'] || (gp && isButtonPressed(gp, 0))) { // Aãƒœã‚¿ãƒ³
                        moveVector.y += flySpeed * delta;
                    }
                    if (keys['ShiftLeft'] || keys['ShiftRight'] || (gp && isButtonPressed(gp, 6))) { // ZLãƒœã‚¿ãƒ³
                        moveVector.y -= flySpeed * delta;
                    }
                } else {
                    // æ­©è¡Œãƒ¢ãƒ¼ãƒ‰ã§ã®ã‚¸ãƒ£ãƒ³ãƒ—
                    const jumpPressed = keys['Space'] || (gp && isButtonPressed(gp, 0));
                    if (jumpPressed && gameState.canJump) {
                        gameState.velocity.y = 10;
                        gameState.canJump = false;
                    }
                }

                // ã‚²ãƒ¼ãƒ ãƒ‘ãƒƒãƒ‰å³ã‚¹ãƒ†ã‚£ãƒƒã‚¯ï¼ˆã‚«ãƒ¡ãƒ©æ“ä½œï¼‰
                if (gp) {
                    const deadzone = 0.15;
                    const sensitivity = 2.5;
                    const rightX = Math.abs(gp.axes[2]) > deadzone ? gp.axes[2] : 0;
                    const rightY = Math.abs(gp.axes[3]) > deadzone ? gp.axes[3] : 0;

                    if (rightX !== 0 || rightY !== 0) {
                        const euler = new THREE.Euler(0, 0, 0, 'YXZ');
                        euler.setFromQuaternion(camera.quaternion);
                        euler.y -= rightX * sensitivity * delta;
                        euler.x -= rightY * sensitivity * delta;
                        euler.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, euler.x));
                        camera.quaternion.setFromEuler(euler);
                    }

                    // ã‚²ãƒ¼ãƒ ãƒ‘ãƒƒãƒ‰ãƒœã‚¿ãƒ³å‡¦ç†
                    // Bãƒœã‚¿ãƒ³ï¼ˆç ´å£Š/æ”»æ’ƒï¼‰
                    if (isButtonJustPressed(gp, 1)) {
                        const targetMob = getTargetMob();
                        if (targetMob) {
                            // ãƒ¢ãƒ–ã‚’æ”»æ’ƒ
                            targetMob.takeDamage(5);
                            console.log(`Hit ${targetMob.type}! HP: ${targetMob.health}/${targetMob.maxHealth}`);
                            // æŒ¯å‹•ãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯
                            if (gp.vibrationActuator) {
                                gp.vibrationActuator.playEffect('dual-rumble', {
                                    startDelay: 0,
                                    duration: 150,
                                    weakMagnitude: 0.5,
                                    strongMagnitude: 0.7
                                });
                            }
                        } else {
                            // ãƒ–ãƒ­ãƒƒã‚¯ç ´å£Š
                            const target = getTargetBlock();
                            if (target) {
                                const pos = target.object.position;
                                removeBlock(pos.x, pos.y, pos.z);
                                // æŒ¯å‹•ãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯
                                if (gp.vibrationActuator) {
                                    gp.vibrationActuator.playEffect('dual-rumble', {
                                        startDelay: 0,
                                        duration: 100,
                                        weakMagnitude: 0.3,
                                        strongMagnitude: 0.5
                                    });
                                }
                            }
                        }
                    }

                    // Xãƒœã‚¿ãƒ³ï¼ˆé…ç½®ï¼‰
                    if (isButtonJustPressed(gp, 2)) {
                        const target = getTargetBlock();
                        if (target) {
                            const normal = target.face.normal;
                            const pos = target.object.position.clone().add(normal);

                            // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®ä¸­å¿ƒéƒ¨åˆ†ã¨é‡ãªã‚‰ãªã„ã‹ç¢ºèª
                            const playerPos = camera.position;
                            const dx = Math.abs(pos.x - playerPos.x);
                            const dy = pos.y - playerPos.y;
                            const dz = Math.abs(pos.z - playerPos.z);
                            const tooClose = dx < 0.5 && dz < 0.5 && dy > -1.5 && dy < 0.5;

                            if (!tooClose) {
                                addBlock(pos.x, pos.y, pos.z, gameState.currentBlock);
                                // æŒ¯å‹•ãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯
                                if (gp.vibrationActuator) {
                                    gp.vibrationActuator.playEffect('dual-rumble', {
                                        startDelay: 0,
                                        duration: 80,
                                        weakMagnitude: 0.2,
                                        strongMagnitude: 0.3
                                    });
                                }
                            }
                        }
                    }

                    // åå­—ã‚­ãƒ¼ / Lãƒ»Rãƒœã‚¿ãƒ³ï¼ˆãƒ–ãƒ­ãƒƒã‚¯é¸æŠï¼‰
                    const currentSlot = getActiveSlotIndex();
                    const slots = document.querySelectorAll('.inventory-slot');

                    // å·¦ or Lãƒœã‚¿ãƒ³
                    if (isButtonJustPressed(gp, 12) || isButtonJustPressed(gp, 4)) {
                        const newSlot = currentSlot > 0 ? currentSlot - 1 : slots.length - 1;
                        selectInventorySlot(newSlot);
                    }

                    // å³ or Rãƒœã‚¿ãƒ³
                    if (isButtonJustPressed(gp, 13) || isButtonJustPressed(gp, 5)) {
                        const newSlot = currentSlot < slots.length - 1 ? currentSlot + 1 : 0;
                        selectInventorySlot(newSlot);
                    }

                    // ä¸Š
                    if (isButtonJustPressed(gp, 14)) {
                        selectInventorySlot(Math.max(0, currentSlot - 1));
                    }

                    // ä¸‹
                    if (isButtonJustPressed(gp, 15)) {
                        selectInventorySlot(Math.min(slots.length - 1, currentSlot + 1));
                    }

                    // Yãƒœã‚¿ãƒ³ï¼ˆé£›è¡Œãƒ¢ãƒ¼ãƒ‰åˆ‡æ›¿ï¼‰
                    if (isButtonJustPressed(gp, 3)) {
                        gameState.flyMode = !gameState.flyMode;
                        const modeIndicator = document.getElementById('mode-indicator');
                        if (gameState.flyMode) {
                            modeIndicator.textContent = 'âœˆï¸ é£›è¡Œãƒ¢ãƒ¼ãƒ‰';
                            modeIndicator.style.color = '#4CAF50';
                        } else {
                            modeIndicator.textContent = 'ğŸš¶ æ­©è¡Œãƒ¢ãƒ¼ãƒ‰';
                            modeIndicator.style.color = '#FFA500';
                        }
                        console.log('é£›è¡Œãƒ¢ãƒ¼ãƒ‰:', gameState.flyMode);
                    }

                    // +ãƒœã‚¿ãƒ³ï¼ˆãƒ¡ãƒ‹ãƒ¥ãƒ¼è¡¨ç¤ºï¼‰
                    if (isButtonJustPressed(gp, 9)) {
                        controls.unlock();
                    }
                }

                // ä½ç½®æ›´æ–°
                if (gameState.flyMode) {
                    // é£›è¡Œãƒ¢ãƒ¼ãƒ‰ï¼šè¡çªåˆ¤å®šãªã—ã§è‡ªç”±ç§»å‹•
                    camera.position.add(moveVector);
                } else {
                    // æ­©è¡Œãƒ¢ãƒ¼ãƒ‰ï¼šè¡çªåˆ¤å®šä»˜ãç§»å‹•
                    const newPos = camera.position.clone();
                    newPos.x += moveVector.x;
                    if (!checkCollision(newPos)) {
                        camera.position.x = newPos.x;
                    }

                    newPos.set(camera.position.x, camera.position.y, camera.position.z);
                    newPos.z += moveVector.z;
                    if (!checkCollision(newPos)) {
                        camera.position.z = newPos.z;
                    }

                    newPos.set(camera.position.x, camera.position.y, camera.position.z);
                    newPos.y += gameState.velocity.y * delta;
                    if (!checkCollision(newPos)) {
                        camera.position.y = newPos.y;
                    } else {
                        if (gameState.velocity.y < 0) {
                            gameState.canJump = true;
                        }
                        gameState.velocity.y = 0;
                    }
                }

                // ãƒ¢ãƒ–æ›´æ–°
                for (const mob of gameState.mobs) {
                    mob.update(delta);
                }

                        // UIæ›´æ–°
                const pos = camera.position;
                let posText = `${Math.floor(pos.x)}, ${Math.floor(pos.y)}, ${Math.floor(pos.z)}`;

                // ã‚²ãƒ¼ãƒ ãƒ‘ãƒƒãƒ‰ãƒ‡ãƒãƒƒã‚°æƒ…å ±
                if (gp) {
                    const axes = gp.axes.map(a => a.toFixed(2)).join(', ');
                    const buttons = gp.buttons.map((b, i) => b.pressed ? i : '').filter(x => x !== '').join(',');
                    posText += ` | GP: axes[${axes}] btns[${buttons}]`;
                }

                document.getElementById('position').textContent = posText;
            }

            prevTime = time;
            renderer.render(scene, camera);
        }

        // ãƒªã‚µã‚¤ã‚ºå¯¾å¿œ
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // åˆæœŸåŒ–
        generateWorld();
        animate();
    </script>
</body>
</html>
